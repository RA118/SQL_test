{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "2024.9.252", "generated_at": "2024-09-28T13:12:58.908514Z", "invocation_id": "2b84ab81-6df7-43aa-9f51-c8c82ca89c8b", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-28T13:12:58.686737Z", "completed_at": "2024-09-28T13:12:58.698466Z"}, {"name": "execute", "started_at": "2024-09-28T13:12:58.700708Z", "completed_at": "2024-09-28T13:12:58.700729Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.06107521057128906, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.sql_test.avg_time_for_store_to_perform_five_transactions", "compiled": true, "compiled_code": "SELECT AVG(diff_hours) AS avg_time --overall avg\nFROM\n\t(SELECT \n\t-- here we calculate differences\n\t\tstore_id\n\t\t, store_name\n\t\t, MAX(happened_at) OVER (PARTITION BY store_id) AS fifth_transaction_time -- for presentation and qa purpose\n\t\t, MIN(happened_at) OVER (PARTITION BY store_id) AS first_transaction_time -- for presentation and qa purpose\n\t\t, DATETIME_DIFF(\n\t\t\t\tMAX(happened_at) OVER (PARTITION BY store_id) \n\t\t  , MIN(happened_at) OVER (PARTITION BY store_id)\n\t\t  , HOUR\n\t\t) AS diff_hours -- DATETIME_DIFF is BQ function, might be different in another DB\n\t\tFROM\n\t\t\t(SELECT\n\t\t\t-- here we count transactions per store\n\t\t\ts.id AS store_id,\n\t\t\ts.name AS store_name,\n\t\t\thappened_at,\n\t\t\tROW_NUMBER() OVER (PARTITION BY s.id ORDER BY happened_at ASC) AS nth_transaction,\n\t\t\tCOUNT(*) OVER (PARTITION BY s.id) AS max_transactions_per_store\n\n\t\t\tFROM sandbox.transactions t\n\t\t\tLEFT JOIN sandbox.device d ON t.device_id = d.id\n\t\t\tLEFT JOIN sandbox.store s ON d.store_id = s.id\n\n\t\t\tWHERE LOWER(status) = 'accepted'\n\t\t\t--AND DATE(t.happened_at) BETWEEEN DATETRUNC(TODAY(), month) AND TODAY()\n\t\t\tGROUP BY 1,2,3\n\t\t\t--ORDER BY 1,3 DESC;\n\t\t\t)\n\tWHERE max_transactions_per_store >=5 -- stores have 5 or more transactions\n\tAND nth_transaction = 1 OR nth_transaction = 5 -- we need 1st and 5th\n)", "relation_name": "`clean-wonder-435309-m2`.`dbt_ra118`.`avg_time_for_store_to_perform_five_transactions`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-28T13:12:58.693737Z", "completed_at": "2024-09-28T13:12:58.699159Z"}, {"name": "execute", "started_at": "2024-09-28T13:12:58.701646Z", "completed_at": "2024-09-28T13:12:58.701655Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 0.1029350757598877, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.sql_test.avg_transacted_amount_per_store_with_typology_and_country", "compiled": true, "compiled_code": "--Average transacted amount per store with typology and country\nSELECT\n\ns.country AS store_country,\ns.typology AS store_typology,\nAVG(t.amount) AS transacted_amount\n\nFROM sandbox.transactions t\nLEFT JOIN sandbox.device d ON t.device_id = d.id\nLEFT JOIN sandbox.store s ON d.store_id = s.id\n\nWHERE LOWER(status) = 'accepted'\n--AND DATE(t.happened_at) BETWEEEN DATETRUNC(TODAY(), month) AND TODAY() -- in real life there will be limitation\nGROUP BY 1,2", "relation_name": "`clean-wonder-435309-m2`.`dbt_ra118`.`avg_transacted_amount_per_store_with_typology_and_country`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-28T13:12:58.694719Z", "completed_at": "2024-09-28T13:12:58.699690Z"}, {"name": "execute", "started_at": "2024-09-28T13:12:58.702113Z", "completed_at": "2024-09-28T13:12:58.702121Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 0.1415717601776123, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.sql_test.percentage_of_transactions_per_device_type", "compiled": true, "compiled_code": "SELECT AVG(diff_hours) AS avg_time --overall avg\nFROM\n\t(SELECT \n\t-- here we calculate differences\n\t\tstore_id\n\t\t, store_name\n\t\t, MAX(happened_at) OVER (PARTITION BY store_id) AS fifth_transaction_time -- for presentation and qa purpose\n\t\t, MIN(happened_at) OVER (PARTITION BY store_id) AS first_transaction_time -- for presentation and qa purpose\n\t\t, DATETIME_DIFF(\n\t\t\t\tMAX(happened_at) OVER (PARTITION BY store_id) \n\t\t  , MIN(happened_at) OVER (PARTITION BY store_id)\n\t\t  , HOUR\n\t\t) AS diff_hours -- DATETIME_DIFF is BQ function, might be different in another DB\n\t\tFROM\n\t\t\t(SELECT\n\t\t\t-- here we count transactions per store\n\t\t\ts.id AS store_id,\n\t\t\ts.name AS store_name,\n\t\t\thappened_at,\n\t\t\tROW_NUMBER() OVER (PARTITION BY s.id ORDER BY happened_at ASC) AS nth_transaction,\n\t\t\tCOUNT(*) OVER (PARTITION BY s.id) AS max_transactions_per_store\n\n\t\t\tFROM sandbox.transactions t\n\t\t\tLEFT JOIN sandbox.device d ON t.device_id = d.id\n\t\t\tLEFT JOIN sandbox.store s ON d.store_id = s.id\n\n\t\t\tWHERE LOWER(status) = 'accepted'\n\t\t\t--AND DATE(t.happened_at) BETWEEEN DATETRUNC(TODAY(), month) AND TODAY()\n\t\t\tGROUP BY 1,2,3\n\t\t\t--ORDER BY 1,3 DESC;\n\t\t\t)\n\tWHERE max_transactions_per_store >=5 -- stores have 5 or more transactions\n\tAND nth_transaction = 1 OR nth_transaction = 5 -- we need 1st and 5th\n)", "relation_name": "`clean-wonder-435309-m2`.`dbt_ra118`.`percentage_of_transactions_per_device_type`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-28T13:12:58.696684Z", "completed_at": "2024-09-28T13:12:58.700304Z"}, {"name": "execute", "started_at": "2024-09-28T13:12:58.702611Z", "completed_at": "2024-09-28T13:12:58.702617Z"}], "thread_id": "Thread-4 (worker)", "execution_time": 0.18041253089904785, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.sql_test.top_ten_products_sold", "compiled": true, "compiled_code": "-- Top 10 products sold\nSELECT\nt.product_sku, -- added because different products might have same name\nt.product_name AS product_name,\nSUM(t.amount) AS transacted_amount\n\nFROM sandbox.transactions t\n--LEFT JOIN device d ON t.device_id = d.id -- don't need them here as all the fields are from t\n--LEFT JOIN store s ON d.store_id = s.id -- don't need them here as all the fields are from t\n\nWHERE LOWER(status) = 'accepted'\n--AND DATE(t.happened_at) BETWEEEN DATETRUNC(TODAY(), MONTH) AND TODAY() -- in real life there will be limitation\nGROUP BY 1,2\nORDER BY 3 DESC\nLIMIT 10", "relation_name": "`clean-wonder-435309-m2`.`dbt_ra118`.`top_ten_products_sold`"}, {"status": "success", "timing": [{"name": "compile", "started_at": "2024-09-28T13:12:58.697588Z", "completed_at": "2024-09-28T13:12:58.701225Z"}, {"name": "execute", "started_at": "2024-09-28T13:12:58.743320Z", "completed_at": "2024-09-28T13:12:58.743333Z"}], "thread_id": "Thread-5 (worker)", "execution_time": 0.21913528442382812, "adapter_response": {}, "message": null, "failures": null, "unique_id": "model.sql_test.top_ten_stores_per_transacted_amount", "compiled": true, "compiled_code": "-- Top 10 stores per transacted amount\nSELECT\ns.id AS store_id, -- added because different stores might have same name\ns.name AS store_name,\nSUM(t.amount) AS transacted_amount\n\nFROM sandbox.transactions t\nLEFT JOIN sandbox.device d ON t.device_id = d.id\nLEFT JOIN sandbox.store s ON d.store_id = s.id\n\nWHERE LOWER(t.status) = 'accepted'\n--AND DATE(t.happened_at) BETWEEEN DATETRUNC(TODAY(), MONTH) AND TODAY() -- in real life there will be limitation\nGROUP BY 1,2 ORDER BY 3 DESC\nLIMIT 10", "relation_name": "`clean-wonder-435309-m2`.`dbt_ra118`.`top_ten_stores_per_transacted_amount`"}], "elapsed_time": 0.5662755966186523, "args": {"select": [], "log_format": "json", "print": true, "version_check": true, "use_colors": true, "defer": true, "indirect_selection": "eager", "macro_debugging": false, "log_path": "/usr/src/dbt-server-shared/working_dir/e067b911-2678-40b9-9cfc-d58358b8483f", "static_parser": true, "strict_mode": false, "which": "generate", "log_file_max_bytes": 0, "send_anonymous_usage_stats": true, "warn_error_options": {"include": [], "exclude": []}, "partial_parse_file_diff": true, "project_dir": "/usr/src/develop/user-70403103947377/environment-70403103961578/repository-70403103943939", "invocation_command": "dbt -A dbt_worker.app worker --loglevel=DEBUG --concurrency=2 --max-memory-per-child=500000", "state": "/usr/src/dbt-server-shared/defer_state/run-70403122903711", "exclude": [], "source_freshness_run_project_hooks": false, "require_explicit_package_overrides_for_builtin_materializations": true, "static": false, "empty_catalog": false, "log_level_file": "debug", "require_resource_names_without_spaces": false, "vars": {}, "populate_cache": true, "profile": "user", "use_colors_file": true, "cache_selected_only": false, "write_json": true, "log_level": "info", "quiet": false, "printer_width": 80, "compile": true, "partial_parse": true, "favor_state": false, "log_format_file": "json", "profiles_dir": "/usr/src/dbt-server-shared/.dbt", "introspect": true, "show_resource_report": false}}